容器oom报错导致network io timeout。日志不连续。
pod存在，底层容器重启。
k8s容器 pod OOM, exit code:137
容器OOM是因为容器占用内存超过了配置里内存的limit设置，导致容器服务把容器kill掉了，对与服务而言这时还是正常的，自然不会dump 日志了。理解了这层含义后，大致猜测jvm内存设置不合理，运行期间堆内存逐渐增大，jvm最大内存还没到，但是已经达到了容器内存的最大限制，然后容器被kill掉了。
实际使用=堆内存+元空间+Off堆

Off heap通常由类元数据，编译代码，线程和GC数据组成。GC数据是可变的，而其余部分应该对大多数应用程序保持静态。此内存是本机的（是的，包括元空间），JVM使用主机上的可用内存来增长或垃圾收集此数据。

鼓励你阅读米哈伊尔这篇优秀的博客文章，以获得更好的观点。

回到手头的问题，JVM占用了500 MB，因为底层主机有16 GB的存储空间。有时这个数字可能高于我们设置的缓冲区，这将导致容器被终止。JVM不应该读取docker容器的内存限制吗？

容器和Java

事实证明，Java版本9及以下版本根本不了解容器/Docker（默认情况下）。它从底层主机中获取可用的CPU和内存。在容器内的主机上运行的每个Java应用程序都依赖于主机配置。考虑到我们是Kubernetes并且许多pod在单个节点上运行，这可能会导致我们面临的问题。

Java 10支持开箱即用的容器，它将查找linux cgroup信息。这允许JVM基于容器限制进行垃圾收集。默认情况下使用标志打开它。

-XX:+UseContainerSupport

值得庆幸的是，其中一些功能已被移植到8u131和9以后。可以使用以下标志打开它们。

-XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap

总结

较旧版本的Java读取底层主机，并且不了解cgroup。这会导致容器配置和Java进程不匹配。这种不匹配在CPU和内存上。Java有一个Off堆内存组件，它有一个动态GC数据组件，可以增长。解决此问题的最佳方法是使用最新版Java中提供的容器支持功能。不要依赖缓冲（这是浪费钱）。

如果您必须继续使用这些主要版本并打开实验标志，请升级到Java 8u131 +或Java 9。更好的是，如果你可以获得Java 10以上将对所有容器有好处。
